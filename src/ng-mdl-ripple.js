(function () {
'use strict';

function MaterialRippleService(Mdl) { 'ngInject';

  /**
   * Class constructor for Ripple MDL component.
   * Implements MDL component design pattern defined at:
   * https://github.com/jasonmayes/mdl-component-design-pattern
   *
   * @constructor
   * @param {HTMLElement} element The element that will be upgraded.
   */
  function MaterialRipple(element, ctx) {
    this.element_ = element;

    // Initialize instance.
    this.init(ctx);
  };

  /**
   * Store constants in one place so they can be updated easily.
   *
   * @enum {string | number}
   * @private
   */
  MaterialRipple.prototype.Constant_ = {
    INITIAL_SCALE:   'scale(0.0001, 0.0001)',
    INITIAL_SIZE:    '1px',
    INITIAL_OPACITY: '0.4',
    FINAL_OPACITY:   '0',
    FINAL_SCALE:     ''
  };

  /**
   * Store strings for class names defined by this component that are used in
   * JavaScript. This allows us to simply change it in one place should we
   * decide to modify at a later date.
   *
   * @enum {string}
   * @private
   */
  MaterialRipple.prototype.CssClasses_ = {
    RIPPLE:       'mdl-ripple',
    IS_ANIMATING: 'is-animating',
    IS_VISIBLE:   'is-visible'
  };

  /**
   * Handle mouse / finger down on element.
   *
   * @param {Event} event The event that fired.
   * @private
   */
  MaterialRipple.prototype.downHandler_ = function(event) {
    if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
      var rect = this.element_.getBoundingClientRect();
      this.boundHeight = rect.height;
      this.boundWidth = rect.width;
      this.rippleSize_ = Math.sqrt(rect.width * rect.width +
          rect.height * rect.height) * 2 + 2;
      this.rippleElement_.style.width = this.rippleSize_ + 'px';
      this.rippleElement_.style.height = this.rippleSize_ + 'px';
    }

    this.rippleElement_.classList.add(this.CssClasses_.IS_VISIBLE);

    if (event.type === 'mousedown' && this.ignoringMouseDown_) {
      this.ignoringMouseDown_ = false;
    } else {
      if (event.type === 'touchstart') {
        this.ignoringMouseDown_ = true;
      }
      var frameCount = this.getFrameCount();
      if (frameCount > 0) {
        return;
      }
      this.setFrameCount(1);
      var bound = event.currentTarget.getBoundingClientRect();
      var x;
      var y;
      // Check if we are handling a keyboard click.
      if (event.clientX === 0 && event.clientY === 0) {
        x = Math.round(bound.width / 2);
        y = Math.round(bound.height / 2);
      } else {
        var clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
        var clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
        x = Math.round(clientX - bound.left);
        y = Math.round(clientY - bound.top);
      }
      this.setRippleXY(x, y);
      this.setRippleStyles(true);
      window.requestAnimationFrame(this.animFrameHandler.bind(this));
    }
  };

  /**
   * Handle mouse / finger up on element.
   *
   * @param {Event} event The event that fired.
   * @private
   */
  MaterialRipple.prototype.upHandler_ = function(event) {
    // Don't fire for the artificial "mouseup" generated by a double-click.
    if (event && event.detail !== 2) {
      // Allow a repaint to occur before removing this class, so the animation
      // shows for tap events, which seem to trigger a mouseup too soon after
      // mousedown.
      window.setTimeout(function() {
        this.rippleElement_.classList.remove(this.CssClasses_.IS_VISIBLE);
      }.bind(this), 0);
    }
  };

  /**
   * Initialize element.
   */
  MaterialRipple.prototype.init = function(ctx) {
    this.rippleContainer_ = document.createElement('span');
    this.rippleContainer_.classList.add(ctx.CssClasses_.RIPPLE_CONTAINER);
    this.rippleElement_ = document.createElement('span');
    this.rippleElement_.classList.add(this.CssClasses_.RIPPLE);
    this.rippleContainer_.appendChild(this.rippleElement_);
    this.element_.appendChild(this.rippleContainer_);

    this.frameCount_ = 0;
    this.rippleSize_ = 0;
    this.x_ = 0;
    this.y_ = 0;

    // Touch start produces a compat mouse down event, which would cause a
    // second ripples. To avoid that, we use this property to ignore the first
    // mouse down after a touch start.
    this.ignoringMouseDown_ = false;

    this.boundDownHandler = this.downHandler_.bind(this);
    this.element_.addEventListener('mousedown', this.boundDownHandler);
    this.element_.addEventListener('touchstart', this.boundDownHandler);

    this.boundUpHandler = this.upHandler_.bind(this);
    this.element_.addEventListener('mouseup', this.boundUpHandler);
    this.element_.addEventListener('mouseleave', this.boundUpHandler);
    this.element_.addEventListener('touchend', this.boundUpHandler);
    this.element_.addEventListener('blur', this.boundUpHandler);

    /**
     * Getter for frameCount_.
     * @return {number} the frame count.
     */
    this.getFrameCount = function() {
      return this.frameCount_;
    };

    /**
     * Setter for frameCount_.
     * @param {number} fC the frame count.
     */
    this.setFrameCount = function(fC) {
      this.frameCount_ = fC;
    };

    /**
     * Getter for rippleElement_.
     * @return {Element} the ripple element.
     */
    this.getRippleElement = function() {
      return this.rippleElement_;
    };

    /**
     * Sets the ripple X and Y coordinates.
     * @param  {number} newX the new X coordinate
     * @param  {number} newY the new Y coordinate
     */
    this.setRippleXY = function(newX, newY) {
      this.x_ = newX;
      this.y_ = newY;
    };

    /**
     * Sets the ripple styles.
     * @param  {boolean} start whether or not this is the start frame.
     */
    this.setRippleStyles = function(start) {
      var transformString;
      var scale;
      var size;
      var offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';

      if (start) {
        scale = this.Constant_.INITIAL_SCALE;
        size = this.Constant_.INITIAL_SIZE;
      } else {
        scale = this.Constant_.FINAL_SCALE;
        size = this.rippleSize_ + 'px';
        if (this.recentering) {
          offset = 'translate(' + this.boundWidth / 2 + 'px, ' +
            this.boundHeight / 2 + 'px)';
        }
      }

      transformString = 'translate(-50%, -50%) ' + offset + scale;

      this.rippleElement_.style.webkitTransform = transformString;
      this.rippleElement_.style.msTransform = transformString;
      this.rippleElement_.style.transform = transformString;

      Mdl.ifClass(this.rippleElement_, !start, this.CssClasses_.IS_ANIMATING);
    };

    /**
     * Handles an animation frame.
     */
    this.animFrameHandler = function() {
      if (this.frameCount_-- > 0) {
        window.requestAnimationFrame(this.animFrameHandler.bind(this));
      } else {
        this.setRippleStyles(false);
      }
    };

  };

  var MaterialRippleService;

  return MaterialRippleService = {
    addRippleEffect: function (element, ctx) {
      return new MaterialRipple(element, ctx);
    },
    removeRippleEffect: function (element, ctx) {
      for(var i in parent.childNodes) {
        var sw = parent.childNodes[i].classList
            && parent.childNodes[i].classList.contains(ctx.CssClasses_.RIPPLE_CONTAINER);
        if (!sw) continue;
        parent.removeChild(parent.childNodes[i]);
      }
    },
    watchIgnoreProperty: function ($scope, element, ctx, created) {
      var ignoreRippleEffectAttribute = element.getAttribute('ignore-ripple-effect');
      $scope.$watch(ignoreRippleEffectAttribute, function () {
        var ignoreRippleEffectAttribute = element.getAttribute('ignore-ripple-effect');
        var ignoreRippleEffect = ignoreRippleEffectAttribute==='' || $scope.$eval(ignoreRippleEffectAttribute);
        if (!ignoreRippleEffect) {
          var ripple = MaterialRippleService.addRippleEffect(element, ctx);
          created && created(ripple);
        } else {
          MaterialRippleService.removeRippleEffect(element, ctx);
        }
      });
    },
  };
}

angular.module('ng-mdl')

.service('MaterialRippleService', MaterialRippleService);

})();